<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTOS: A Simple RTOS</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>A Simple RTOS</h1>
<p>
This is a simple RTOS that supports pre-emptive multithreading, and interprocess synchronization using Events.<p>
<b>Note:</b> Please don't edit the interface file "os.h".<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Dr. Mantis Cheng </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>26 September 2007</dd></dl>
<h2><a class="anchor" name="assumptions">
GLOBAL ASSUMPTIONS</a></h2>
(ATMEL specific)<ul>
<li>Counter1 Timer and SWI interrupts are reserved.</li></ul>
<p>
<ul>
<li>All runtime exceptions (where assumptions are violated) or other unrecoverable errors get handled by calling <a class="el" href="os_8c.html#b5747390a8be675282cb93e5198bd085">OS_Abort()</a>.</li><li>Each valid entry in PPP[] must be non-zero except IDLE.</li><li>All unspecified runtime errors have undefined behaviours, e.g., stack overflow.</li><li>PPP[] <b>cannot</b> be modified once the application starts running.</li></ul>
<h2><a class="anchor" name="policy">
SCHEDULING POLICY</a></h2>
There are three scheduling levels: SYSTEM, PERIODIC and RR. These levels are prioritized with SYSTEM being the highest, and RR being the lowest.<p>
Preemption occurs immediately. Whenever preemption is feasible, it takes place instantly. As soon as a higher priority task becomes ready, it preempts all lower priority tasks.<h2><a class="anchor" name="system">
SYSTEM TASKS</a></h2>
SYSTEM (level) tasks are FCFS; they run to completion, i.e., until they terminate, block or yield. Thus, they are non-preemptible, not even by other SYSTEM tasks. They should only be used for critical system level activities, e.g., error or fault recovery. Running too many SYSTEM tasks could affect the real time performance of all other low level tasks.<h2><a class="anchor" name="periodic">
PERIODIC TASKS</a></h2>
PERIODIC tasks are scheduled based on a fixed cyclic scheduling plan; they are time-based. (See below about PPP[].) Since they are time-critical, they are <b>NOT</b> allowed to block (i.e., wait on an event). When a PERIODIC task is created, it is assigned a "name", a non-zero user-defined constant between 1 and MAXPROCESS. This name is fixed and can NEVER be changed again. No two PERIODIC tasks have the same name. All names are unique. Since tasks may terminate and be created again over time, the same name may be reused over time for different PERIODIC task instance.<p>
The PPP[] array is essentially a linear representation of a Gantt diagram. It is an array of [Name1, Interval1, Name2, Interval 2, ... ]. The name of every PERIODIC task must appear in PPP[] array at least once, but may be more than once.<p>
For example, if we create three PERIODIC tasks with names A, B and C out of three functions P(), Q() and R() respectively. Then, PPP[] = { A, 2, B, 3, A, 5, C, 1 } means executing A for 2 ticks, then B for 3 ticks, then A again for 5 ticks, then C for 1 tick, then A again, and so on. The total cycle time is 2+3+5+1=11 ticks. That is, within 11 ticks, A executes twice, B once and C once. If P() terminates, but the name A is later assigned to another function U(), then A will be executed again according to PPP[] order using U(). In a sense, PPP[] specifies at least a single execution cycle of all PERIODIC tasks. IDLE is a special PERIODIC task name, which means do nothing during this task's assigned interval.<p>
A PERIODIC task may yield (calling <a class="el" href="os_8c.html#5a9b72d0dadaea32fec8d4ff1c0eafa4">Task_Next()</a>) to relinquish the processor before its assigned interval. In this case, it has completed its current execution interval and is waiting for its next interval.<p>
It is a runtime error if a PERIODIC task executes longer than the currently assigned interval. It is important NOT to underestimate the execution time requirement of a PERIODIC task. Choosing the appropriate execution order and intervals for all PERIODIC tasks is the responsibility of the Application Design Engineer(s), not our RTOS. Hence, all timing violations should be caught and then reported.<p>
By specifying PPP[] and scheduling our PERIODIC tasks accordingly, we shall know precisely the execution "cycle" time of all such tasks, thus their best execution frequency/rate and response time. This is how we guarantee the predictability of timing and ordering all critical activities.<h2><a class="anchor" name="rr">
RR TASKS</a></h2>
RR tasks are scheduled in a round-robin fashion, i.e., each RR task runs for one TICK approximately and yields to the next RR task. They don't have any time critical schedule to follow, thus they share the processor cycles fairly.<p>
RR tasks are allowed to run <em>only</em> when no PERIODIC or SYSTEM tasks are executing. When an RR task resumes after pre-emption, it re-enters its RR level at the end. When an RR task yields, or resumes after being unblocked, it re-enters its level at the end as well.<h2><a class="anchor" name="boot">
OS BOOTING</a></h2>
Our RTOS is compiled together with an application. It doesn't provide a "main()" function, which is a part of the application. By convention, the "main()" is the first function to be called by the C runtime code, "crt0.S". For our RTOS, we shall change this convention as follows:<ol type=1>
<li><a class="el" href="os_8c.html#280149a9407c6504ce0af541351561db">OS_Init()</a> is called from <a class="el" href="crt0_8S.html">crt0.S</a> as the very first C function to be executed instead of <a class="el" href="os_8c.html#e66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</li><li>Upon completion of <a class="el" href="os_8c.html#280149a9407c6504ce0af541351561db">OS_Init()</a>, the application's <a class="el" href="os_8c.html#e66f6b31b5ad750f1fe042a706a4e3d4">main()</a> is then created as the first and only SYSTEM level task.</li><li>In <a class="el" href="os_8c.html#e66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, the rest of the application tasks are then created.</li><li>In order for all other application tasks to run, our <a class="el" href="os_8c.html#e66f6b31b5ad750f1fe042a706a4e3d4">main()</a> task must either terminate or block on an event. (For example, <a class="el" href="os_8c.html#e66f6b31b5ad750f1fe042a706a4e3d4">main()</a> may become a "watchdog" task to reset the entire application.)</li></ol>
<h2><a class="anchor" name="ipc">
INTERPROCESS COMMUNICATION</a></h2>
Events are one-way synchronization signals. They don't have any "memory" (i.e., values); thus, they are NOT semaphores. Any SYSTEM or RR task may wait on an event; PERIODIC tasks <b>MUST</b> <b>NOT</b> wait on any event. However, any task may signal/broadcast an event. A waiting task is resumed when the associated event is signalled. All waiting tasks are resumed when the associated event is broadcasted. When an event is signalled (or broadcasted) but there are no waiting tasks, this is a <em>no-op</em>; hence, events have <b>no</b> memory. <hr size="1"><address style="align: right;"><small>Generated on Tue Oct 23 21:49:51 2007 for RTOS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
