<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="eng" xml:lang="eng">
<head>
<title>CSC 460: Report 2 - Testing</title>
<style type="text/css">@import url(report2.css);</style>
</head>
<body>

<div id="container">

<div id="top">Scott Craig and Justin Tanner</div>

<div id="menu">
<ul>
    <li><a href="index.html">Home</a>&nbsp;|</li>
    <li><a href="design.html">Design</a>&nbsp;|</li>
    <li><a href="scheduler.html">Scheduler</a>&nbsp;|</li>
    <li><a href="context_switch.html">Context Switching</a>&nbsp;|</li>
    <li><a href="crt0.html">C Runtime</a>&nbsp;|</li>
    <li><a href="one_file.html">One File</a>&nbsp;|</li>
    <li><a href="volatile.html">Volatile</a>&nbsp;|</li>
    <li><a class="current" href="testing.html">Testing</a>&nbsp;|</li>
    <li><a href="test_cases.html">Test Cases</a>&nbsp;|</li>    
    <li><a href="code.html">Code</a></li>
</ul>
</div>

<div id="content">
<h1>Testing</h1>

<p>Testing a real-time operating system is a difficult task. Various contraints limit the tester's ability to fully test an RTOS without affecting performance.  These are the approaches that we used to test our RTOS.</p>

<h2>Testing Limitations</h2>

<p>Out of the box the AT90USBKey has only a handful of useful testing methods.</p>

<ol>
    <li>Toggle the four LEDs</li>
    <li>Step though the code in AVR Simulator</li>    
</ol>

<p>Both of the these approaches have some serious problems. AVR Simulator does not emulate external hardware devices, limiting testing to the basic kernel operations.  And blinking LEDs can lead to ambiguous debugging.</p>

<h2>Error Codes</h2>

<p>We decided to use the onboard LEDs to display error blink codes.  A blink code is similar to a <a href="http://www.amptron.com/html/bios.beepcodes.html">BIOS beep code</a>.  Blink codes alert the developer of a problem without using a display.</p>

<p>Displayed a blink code is done by first turning all the lights for a short burst, then a blink code in shorter bursts of RED ( run-time error ) or GREEN ( initialization error ).</p>

<pre class="code">
    <span class="construct">ALL_LIGHTS</span> <span class="type">GREEN</span> <span class="type">GREEN</span> <span class="type">GREEN</span>
</pre>

<p>The above textual representation of a blink code is indicating initialization error number three.  Which the user of the RTOS may lookup in <code>error_codes.h</code></p>

<pre class="code">
...

<span class="comment">/** PERIODIC name is out of range [1 .. MAXNAME] */</span>
<span class="ident">ERR_2_CREATE_NAME_OUT_OF_RANGE</span>,

<span class="comment">/** PERIODIC task assigned name IDLE */</span>
<span class="ident">ERR_3_PERIODIC_NAMED_IDLE</span>,

<span class="comment">/** PERIODIC name already used */</span>
<span class="ident">ERR_4_PERIODIC_NAME_IN_USE</span>,

...

</pre>

<h2>Traces</h2>

<p>A trace is a log file.  When used to to debug operating systems, it is often called a kernel trace.  A kernel trace is a log that contains all the steps preformed by an operating system during the execution of a program.</p>

<p>Projects such as SUN's <a href="http://www.sun.com/bigadmin/content/dtrace/">DTRACE</a> provides tracing abilities to Solaris, Linux, and Mac OSX Leopard.  Kernel tracing would be an excellent way to fully test our RTOS, but due to limitation on memory and debugging methods a kernel trace was not used.</p>

<p>Instead we will use simple traces generated by the users application.  These traces will contain simple log data accumulated at key points during the operation of a test.</p>

<h2>Setting up the Trace</h2>

<p>Since the AT90USBKey has no display, we must extract our trace data using UART.  A simple RS232 interface connects the AT90USBKey to a terminal computer collecting data. </p>

<div class="centered_image"><img src="images/hyperterminal.jpg" alt="hyperterminal" border="1" /></div>
<h2>An Example</h2>

<p>The following is an example of a simple test designed to test the basic functionality of periodic tasks.</p>

<pre class="code">
    
<span class="ident">enum</span> { A=1, B, C, D, E, F, G };
<span class="type">const unsigned int</span> <span class="ident">PT</span> = 7;
<span class="type">const unsigned char</span> <span class="ident">PPP</span>[] = {A, 5, B, 5, C, 5, D, 5, E, 5, F, 5};

<span class="type">EVENT*</span> <span class="ident">print_event</span>;

<span class="type">void</span> <span class="ident">generic_task</span>(<span class="type">void</span>)
{
    <span class="type">int</span> <span class="ident">arg</span> = 0;
    <span class="ident">arg</span> = <span class="ident">Task_GetArg</span>();
    
    <span class="construct">for</span>(;;)
    {
        <span class="ident">add_to_trace</span>(<span class="ident">arg</span>);
        <span class="ident">Task_Next</span>();
    }
}

<span class="type">int</span> <span class="ident">main</span>(<span class="type">void</span>)
{
    <span class="comment">/* setup the test */</span>
    <span class="ident">uart_init</span>();
    <span class="ident">uart_write</span>((<span class="type">uint8_t*</span>)"\r\nSTART\r\n", 9);
    <span class="ident">set_test</span>(2);
    
    <span class="ident">print_event</span> = <span class="ident">Event_Init</span>();
      
    <span class="ident">Task_Create</span>(generic_task, A, PERIODIC, A);
    <span class="ident">Task_Create</span>(generic_task, B, PERIODIC, B);
    <span class="ident">Task_Create</span>(generic_task, C, PERIODIC, C);
    <span class="ident">Task_Create</span>(generic_task, D, PERIODIC, D);
    <span class="ident">Task_Create</span>(generic_task, E, PERIODIC, E);
    <span class="ident">Task_Create</span>(generic_task, F, PERIODIC, F);    

    <span class="ident">Event_Wait</span>(<span class="ident">print_event</span>);
    <span class="ident">print_trace</span>();        
}

</pre>

<p>In this code the function <code>add_to_trace(int)</code> adds an integer to the log file.  This function simply places the integer in an array and does not send it over UART.  This avoids problems with latency, and trace functions affecting the results of our test.  The function <code>print_trace</code> takes all the accumulated integers and prints them to UART.  This function is only called at the end of the test signaled by <code>add_to_trace()</code> when it has accumulated enough datax. </p>

<h2>The Expected Output</h2>

<p>The expected output of this test is for all the periodic tasks to run in a first come first served fashion.</p>

<pre class="code">
    T002;1;2;3;4;5;6;1;2;3;4;5;6;1;2;3;4;5;6;1;2;3;4;5;6;..    
</pre>

<p>T002 indicates the this is test number two, and the semi-colon delimited numbers represent the PPP array name value of the task.  The order we created them was 1,2,3,4,5,6 therefore we expected the same FCFS ordering to appear in the trace.</p>

<p>Now its time to run some <a href="test_cases.html">tests</a>.</p>

</div>

<div id="menu">
<ul>
    <li><a href="index.html">Home</a>&nbsp;|</li>
    <li><a href="design.html">Design</a>&nbsp;|</li>
    <li><a href="scheduler.html">Scheduler</a>&nbsp;|</li>
    <li><a href="context_switch.html">Context Switching</a>&nbsp;|</li>
    <li><a href="crt0.html">C Runtime</a>&nbsp;|</li>
    <li><a href="one_file.html">One File</a>&nbsp;|</li>
    <li><a href="volatile.html">Volatile</a>&nbsp;|</li>
    <li><a class="current" href="testing.html">Testing</a>&nbsp;|</li>
    <li><a href="test_cases.html">Test Cases</a>&nbsp;|</li>    
    <li><a href="code.html">Code</a></li>
</ul>
</div>

</div>
</body>
</html>
