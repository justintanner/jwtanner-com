<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="eng" xml:lang="eng">
<head>
<title>CSC 460: Report 2 - Scheduler</title>
<style type="text/css">@import url(report2.css);</style>
</head>
<body>

<div id="container">
    
<div id="top">Scott Craig and Justin Tanner</div>

<div id="menu">
<ul>
    <li><a href="index.html">Home</a>&nbsp;|</li>
    <li><a href="design.html">Design</a>&nbsp;|</li>
    <li><a class="current" href="scheduler.html">Scheduler</a>&nbsp;|</li>
    <li><a href="context_switch.html">Context Switching</a>&nbsp;|</li>
    <li><a href="crt0.html">C Runtime</a>&nbsp;|</li>
    <li><a href="one_file.html">One File</a>&nbsp;|</li>
    <li><a href="volatile.html">Volatile</a>&nbsp;|</li>
    <li><a href="testing.html">Testing</a>&nbsp;|</li>
    <li><a href="test_cases.html">Test Cases</a>&nbsp;|</li>    
    <li><a href="code.html">Code</a></li>
</ul>
</div>

<div id="content">

<h1>Scheduler</h1>

<p>The scheduler is the part of the kernel that decides what task to run next.  The kernel dispatches tasks based on the current running task and other tasks waiting on the kernel.</p>

<h2>Dispatching</h2>

<p>After some initialization, the kernel enters a loop:
<ol>
<li>Select and dispatch a process to run</li>
<li>Exit the kernel. (The loop is left and re-entered here.)</li>
<li>Handle the request from the process that was running.</li>
<li>Goto step one</li>
</ol>
</p>

<p>So effectively, every time the kernel code is entered at its single point of entry,
the request of the currently running task is
responded to, and another task--or maybe the same one depending on the nature of the request
and the state of the other tasks--is selected to run next.</p>

<p>The structure of the kernel function to handle request is simple; it is mostly one long <code>switch</code>
statement that selects the correct action depending on the type of request. Depending on the request, the current
task may be suspended from running, and placed in some queue or terminated. Other tasks may also be moved from
one queue to another. A transition diagram for how the states of tasks change given a particular request is
shown below.</p>

<h2>State Diagram for a Task</h2>
<div class="centered_image">
<img src="images/task_state_diagram.gif" alt="Task state diagram"/>
</div>

<p>For example, if the current task requests to wait on an event, then it will be suspended and
placed in a waiting queue for the event. In another example, if the current task signals on an event,
it may or may not be suspended, depending on the level of the other tasks waiting on that event.</p>

<p>After the request is handled, and the queues are adjusted, another function chooses the next task
to dispatch. For efficiency, the function handling the request looks ahead to see if the current task
needs to be suspended. So if the current task is already running, then it is left running. Otherwise,
a new task is selected based on priority--SYSTEM, PERIODIC, RR--and on the scheduling policy of the various levels:
first-come-first-served for SYSTEM tasks, and round-robin for RR tasks. If the PERIODIC task
for the current time slot has not yet run, and there are no SYSTEM tasks, then it will be chosen.</p>


</div>

<div id="menu">
<ul>
    <li><a href="index.html">Home</a>&nbsp;|</li>
    <li><a href="design.html">Design</a>&nbsp;|</li>
    <li><a class="current" href="scheduler.html">Scheduler</a>&nbsp;|</li>
    <li><a href="context_switch.html">Context Switching</a>&nbsp;|</li>
    <li><a href="crt0.html">C Runtime</a>&nbsp;|</li>
    <li><a href="one_file.html">One File</a>&nbsp;|</li>
    <li><a href="volatile.html">Volatile</a>&nbsp;|</li>
    <li><a href="testing.html">Testing</a>&nbsp;|</li>
    <li><a href="test_cases.html">Test Cases</a>&nbsp;|</li>    
    <li><a href="code.html">Code</a></li>
</ul>
</div>

</div>
</body>
</html>
